/*
 * LiquidBounce+ Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/WYSI-Foundation/LiquidBouncePlus/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.*
import net.minecraft.network.play.INetHandlerPlayClient
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.*
import net.minecraft.network.Packet

import java.util.LinkedList

@ModuleInfo(name = "FakeLag", spacedName = "Fake Lag", description = "Lagging yourself server-side, and client-side.", category = ModuleCategory.EXPLOIT)
class FakeLag : Module() {

	private val fakeLagMode = ListValue("Mode", arrayOf("All", "InBound", "OutBound"), "All")
	private val fakeLagMoveOnly = BoolValue("MoveOnly", true)

	private val minRand: IntegerValue = object : IntegerValue("MinDelay", 0, 0, 20000, "ms") {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = maxRand.get()
            if (v < newValue) set(v)
        }
    }
    private val maxRand: IntegerValue = object : IntegerValue("MaxDelay", 0, 0, 20000, "ms") {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = minRand.get()
            if (v > newValue) set(v)
        }
    }

	// debug
	private val debugValue = BoolValue("Debug", false)

	// variables
	private val outBus = LinkedList<Packet<INetHandlerPlayServer>>()
	private val inBus = LinkedList<Packet<INetHandlerPlayClient>>()
	
	private val inTimer = MSTimer()
	private val outTimer = MSTimer()

	private var inDelay = 0
	private var outDelay = 0

	private var noModify = false

	fun debug(s: String) {
		if (debugValue.get())
			ClientUtils.displayChatMessage("§7[§6§lFakeLag§7]§f $s")
	}

	override fun onEnable() {
		inBus.clear()
		outBus.clear()

		inTimer.reset()
		outTimer.reset()

		noModify = false
	}

	override fun onDisable() {
		while (inBus.size > 0)
			inBus.poll().processPacket(mc.netHandler)

		while (outBus.size > 0)
			PacketUtils.sendPacketNoEvent(outBus.poll())
			
		inBus.clear()
		outBus.clear()
		mc.timer.timerSpeed = 1F
	}

	@EventTarget
	fun onPacket(event: PacketEvent) {
		val packet = event.packet
	
		if (noModify || mc.thePlayer == null || mc.theWorld == null || mc.thePlayer.ticksExisted <= 0 || mc.isSingleplayer()) return // somehow the fakelag module doesn't work or crash with singleplayer.
		if ((fakeLagMode.get().equals("outbound", true) || fakeLagMode.get().equals("all", true)) && packet::class.java!!.getSimpleName().startsWith("C", true)) {
			debug("outbound, ${packet::class.java!!.getSimpleName()}")
			outBus.add(packet as Packet<INetHandlerPlayServer>)
			event.cancelEvent()
		}
		if ((fakeLagMode.get().equals("inbound", true) || fakeLagMode.get().equals("all", true)) && packet::class.java!!.getSimpleName().startsWith("S", true)) {
			debug("inbound, ${packet::class.java!!.getSimpleName()}")
			inBus.add(packet as Packet<INetHandlerPlayClient>)
			event.cancelEvent()
		}
	}

	@EventTarget
	fun onWorld(event: WorldEvent) {
		inBus.clear()
		outBus.clear()

		inTimer.reset()
		outTimer.reset()
	}

	@EventTarget
	fun onUpdate(event: UpdateEvent) {
		if (!inBus.isEmpty() && ((fakeLagMoveOnly.get() && !MovementUtils.isMoving()) || inTimer.hasTimePassed(inDelay.toLong()))) {
			noModify = true
			while (inBus.size > 0) {
				inBus.poll().processPacket(mc.netHandler)
			}
			noModify = false
			inDelay = RandomUtils.nextInt(minRand.get(), maxRand.get())
			inTimer.reset()
			debug("poll (in)")
		}
		if (!outBus.isEmpty() && ((fakeLagMoveOnly.get() && !MovementUtils.isMoving()) || outTimer.hasTimePassed(outDelay.toLong()))) {
			noModify = true
			while (outBus.size > 0) {
				mc.netHandler.addToSendQueue(outBus.poll())
			}
			noModify = false
			outDelay = RandomUtils.nextInt(minRand.get(), maxRand.get())
			outTimer.reset()
			debug("poll (out)")
		}
	}
}
